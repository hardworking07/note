### 优秀的软件是这样的
+ 容易修改----可维护  
+ 容易新增功能---可扩展
+ 容易用到其他地方-----可复用  
如同活字印刷术一样，我们通过面向对象的思想，利用封装、继承、多态和设计模式，使程序“高内聚，低耦合”，变得更加灵活。

#### 单一职责原则
类的职责要单一，一个类应该仅有一个引起它变化的原因。  
如果一个类承担的职责过多，就等于把不同职责耦合在一起。当一个职责发生变化，就可能影响其他职责的发挥。  
因此，如果能想到多于一个原因使一个类变化，就要拆分。

#### 开放封闭原则
对于扩展是开放的，对于修改是封闭的。  
需求总是变化的，但我们希望代码可以保持一种相对的稳定。也就是只要增加新的代码就可以了，尽可能不改原来的代码。  
这是一个核心原则。

#### 依赖倒转原则
高层模块应该依赖于抽象（接口），而不是低层模块。  
比如：内存是依赖于接口的，所以坏了，只要换内存就可以了。如果它是依赖于具体的主板的，那连主板也要换。  

#### 里氏替换原则
子类应能完全替代父类。  
正是因为这样，我们才能针对接口来编程。  
```c++
Animal *animalPtr = new dog();
animalPtr->run();
animalPtr->eat();
```
上面的例子中，我们只要写个新的Animal类替换，其余代码完全不用变。原因就是子类可以完全替代父类。  

#### 简单工厂模式
有这么几个类：Operator抽象类，具体的OperatorAdd类等，OperatorFactory工厂类。  
+ 可维护----只要修改具体的运算类，不影响其他类 
+ 可扩展----增加一种运算时，只要新写一个类，同时在工厂类中加一句即可
+ 可复用----每一个运算类都能用到其他地方

分类的思想：抽象出共同的属性。  
对于不同的运算类， 本质是：运算。区别是：运算的方式。 所以，用了一个抽象运算类。

UML: OperatorFactory 关联 Operator  

#### 策略模式
UML: Context 聚合 Strategy  
+ 可维护----只要修改具体的运算类，不影响其他类 
+ 可扩展----增加一种运算时，只要新写一个类
+ 可复用----每一个运算类都能用到其他地方

相比于简单工厂模式，当新增一个Strategy类时，并不需要重新编绎Context类, 所以如果策略经常变化（比如商场打折方式），这种方法就更好。

此模式，让算法之间可以相互替换，算法的变化不会影响客户。算法和使用算法的客户代码就解耦了。  

缺点：要使用哪种策略是要在客户代码中进行判断的。所以可以把策略模式 + 简单工厂模式。

#### 装饰模式
UMl: 先有一个具体对象，再给这个对象一层层套上装饰。

可维护：如果某层装饰有变化，只要修改单独的装饰类，不要改其他代码。  
可扩展：新增一个装饰类，就可以实现又一种装饰风格  
可复用：每个装饰类相互独立，可以用在其他地方  

优点：分离了主要职责和次要职责。

缺点：

使用场景：有时候有些职责是在特定情况下才会用的，如果写在一个类里或是子类里，就无法突出核心职责了。

#### 代理模式
UML: proxy 和 realsubject都继承自抽象类， proxy关联realsubject

可维护：
可扩展：
可复用：

优点：
缺点：

使用场景：


#### 


