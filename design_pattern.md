### 优秀的软件是这样的
+ 容易修改----可维护  
+ 容易新增功能---可扩展
+ 容易用到其他地方-----可复用  
如同活字印刷术一样，我们通过面向对象的思想，利用封装、继承、多态和设计模式，使程序“高内聚，低耦合”，变得更加灵活。

#### 单一职责原则
类的职责要单一，一个类应该仅有一个引起它变化的原因。  
如果一个类承担的职责过多，就等于把不同职责耦合在一起。当一个职责发生变化，就可能影响其他职责的发挥。  
因此，如果能想到多于一个原因使一个类变化，就要拆分。

#### 开放封闭原则
对于扩展是开放的，对于修改是封闭的。  
需求总是变化的，但我们希望代码可以保持一种相对的稳定。也就是只要增加新的代码就可以了，尽可能不改原来的代码。  
这是一个核心原则。

#### 依赖倒转原则
高层模块应该依赖于抽象（接口），而不是低层模块。  
比如：内存是依赖于接口的，所以坏了，只要换内存就可以了。如果它是依赖于具体的主板的，那连主板也要换。  

#### 里氏替换原则
子类应能完全替代父类。  
正是因为这样，我们才能针对接口来编程。  
```c++
Animal *animalPtr = new dog();
animalPtr->run();
animalPtr->eat();
```
上面的例子中，我们只要写个新的Animal类替换，其余代码完全不用变。原因就是子类可以完全替代父类。  

#### 简单工厂模式
有这么几个类：Operator抽象类，具体的OperatorAdd类等，OperatorFactory工厂类。  
+ 可维护----只要修改具体的运算类，不影响其他类 
+ 可扩展----增加一种运算时，只要新写一个类，同时在工厂类中加一句即可
+ 可复用----每一个运算类都能用到其他地方

分类的思想：抽象出共同的属性。  
对于不同的运算类， 本质是：运算。区别是：运算的方式。 所以，用了一个抽象运算类。

UML: OperatorFactory 关联 Operator  

#### 策略模式
UML: Context 聚合 Strategy  
+ 可维护----只要修改具体的运算类，不影响其他类 
+ 可扩展----增加一种运算时，只要新写一个类
+ 可复用----每一个运算类都能用到其他地方

相比于简单工厂模式，当新增一个Strategy类时，并不需要重新编绎Context类  


